<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>On Top Of Things</title>
	<link rel="stylesheet" href="base.css">
	<script src="bower_components/jquery/dist/jquery.js"></script>
	<script src="bower_components/react/react-with-addons.js"></script>
	<script src="bower_components/react/JSXTransformer.js"></script>
	<script src="bower_components/director/build/director.js"></script>
	<script src="bower_components/underscore/underscore.js"></script>
	<link rel="stylesheet" href="style.css">
</head>
<body>
<section id="app"></section>

<script type="text/jsx">
var horizon_l = ["new", "today", "next", "week", "month", "quarter", "year"];

function createComparor(criterion_l) {
	return function(a, b) {
		//console.log("criterion_l: "+criterion_l);
		for (var i = 0; i < criterion_l.length; i++) {
			var criterion = criterion_l[i];
			//console.log("criterion: "+criterion);
			if (!a[criterion] && !b[criterion]) {
				// fields are both null
			}
			else if (criterion == "created") {
				var d = a.created.localeCompare(b.created);
				if (d != 0) {
					return d;
				}
			}
			else if (criterion == "folder") {
				if (!_.isEqual(a.folder, b.folder)) {
					if (!a.folder) return -1;
					else if (!b.folder) return 1;
					else return (a.folder < b.folder) ? -1 : 1;
				}
			}
			else if (criterion == "horizon") {
				var ia = horizon_l.indexOf(a.horizon);
				var ib = horizon_l.indexOf(b.horizon);
				var d = ia - ib;
				//console.log(a.horizon+"="+ia+", "+b.horizon+"="+ib);
				if (d != 0)
					return d;
			}
			else {
				// TODO: check whether field is strings, and if so, compare them
			}
		}
		return 0;
	}
}

var TaskItem = React.createClass({
	getInitialState: function() {
		return {
			editing: false
		};
	},
	render: function() {
		var item = this.props.item;
		var folderElem = (!item.folder || this.props['hide-folder']) ? <span/> : <span> /{item.folder.join("/")}: </span>;
		var horizonElem = (!item.horizon || this.props['hide-horizon'])
			? <span/>
			: <span className='field-horizon'> ?{item.horizon} </span>;
		var indexElem = (this.props.index)
			? <span className='index'>{this.props.index}</span>
			: <span/>
		var checkboxElem = (item.closed)
			? <input type='checkbox' className='checkbox-closed' checked/>
			: <input type='checkbox' className='checkbox-closed'/>
		var tag_l = (item.tag || []).map(function(tag) { return <span className={'tag tag-'+tag}>+{tag}</span> });
		var tagElem = (!_.isEmpty(tag_l))
			? <span className='tags'> ({tag_l}) </span>
			: <span/>;
		var itemStyle = (item.deleted) ? {'textDecoration': 'line-through', "color": "#808080"} : {};
		return (
			<li className='task'>
				<div>
					<span style={itemStyle} onDoubleClick={this.toggleEditor}>
						{indexElem}
						{checkboxElem}
						{folderElem}
						{horizonElem}
						{item.title}
						{tagElem}
					</span>
				</div>
				{
					(this.state.editing)
						? <TaskEditor item={item} onTaskChanged={this.props.onTaskChanged}/>
						: null
				}
			</li>
		);
	},
	toggleEditor: function() {
		this.setState({editing: !this.state.editing});
	}
});

var TaskItemHeader = React.createClass({
	render: function() {
		var headerClass = "task-header-"+this.props.level+" field-"+this.props.fieldName;
		return (
			<li className={headerClass}>
				<label>{this.props.fieldValue}</label>
			</li>
		);
	}
});

var TaskList = React.createClass({
	render: function() {
		console.log("TaskList.render()");
		var header_l = this.props.headers;
		console.log(" header_l: "+header_l);
		var header0 = [];
		var itemElems = [];
		var index = 1;
		var hideFolder = (header_l.indexOf("folder") >= 0);
		var hideHorizon = (header_l.indexOf("horizon") >= 0);
		var tempIdMap = {};
		for (var i in this.props.items) {
			var item = this.props.items[i];
			for (var j = 0; j < header_l.length; j++) {
				var fieldName = header_l[j];
				var fieldValue = item[fieldName];
				if (fieldName === "folder") {
					fieldValue = "/"+(fieldValue || []).join("/");
				}
				//console.log("j = "+j+", fieldName = "+fieldName+", fieldValue = "+fieldValue
				// +", header0[j] = "+header0[j]);
				if (!_.isEqual(fieldValue, header0[j])) {
					header0[j] = fieldValue;
					var headerKey = _(header0).first(j + 1).join("|");
					itemElems.push(<TaskItemHeader key={headerKey} level={j+1} fieldName={fieldName} fieldValue={fieldValue}/>);
				}
			}
			itemElems.push(
				<TaskItem key={item.id} item={item} index={index}
					hide-folder={hideFolder} hide-horizon={hideHorizon}
					onTaskChanged={this.props.onTaskChanged}/>);
			index++;
		}

		return (
			<ul className="task-list">
			{itemElems}
			</ul>
		);
	}
});

var TaskListSettings = React.createClass({
	handleSubmit: function() {
		var headers = this.refs.headers.getDOMNode().value.trim();
		var order = this.refs.order.getDOMNode().value.trim();
		var query = this.refs.query.getDOMNode().value.trim();
		var header_l = headers.split(",").map(function(s) { return s.trim(); }).filter(function(s) { return s; });
		var order_l = order.split(",").map(function(s) { return s.trim(); }).filter(function(s) { return s; });
		this.props.onChanged({headers: header_l, order: order_l, query: query});
		return false;
	},
	render: function() {
		return (
			<form onSubmit={this.handleSubmit}>
				Headers: <input ref="headers" type="text" defaultValue="folder"/>
				Order: <input ref="order" type="text" defaultValue="horizon,created"/>
				Query: <input ref="query" type="text" defaultValue=""/>
				<input type='submit' value='List'/>
			</form>
		);
	}
});

function splitInputValue(ref, pattern) {
	return ref.getDOMNode().value.trim().split(pattern).map(function(s) { return s.trim(); }).filter(function(s) { return s; });
}

var TaskEditor = React.createClass({
	handleSubmit: function(e) {
		//e.stopPropogation();
		e.preventDefault();
		var item = this.props.item;
		item.title = this.refs.title.getDOMNode().value.trim();
		item.folder = splitInputValue(this.refs.folder, "/");
		item.horizon = this.refs.horizon.getDOMNode().value.trim();
		item.tag = splitInputValue(this.refs.tag, ",");
		this.props.onTaskChanged(item);
	},
	render: function() {
		var item = this.props.item;
		var folder = (item.folder || []).join("/");
		var tag = (item.tag || []).join(",");
		return (
			<form onSubmit={this.handleSubmit}>
				<fieldset>
					<label>Title:</label>
					<input ref="title" type="text" defaultValue={item.title}/>
					<br/>

					<label>Folder:</label>
					<input ref="folder" type="text" defaultValue={folder}/>
					<br/>

					<label>Horizon:</label>
					<select ref="horizon" defaultValue={item.horizon}>
						<option value="inbox">inbox</option>
						<option value="today">today</option>
						<option value="next">next</option>
						<option value="week">week</option>
						<option value="month">month</option>
						<option value="quarter">quarter</option>
						<option value="year">year</option>
					</select>
					<br/>

					<label>Tags:</label>
					<input ref="tag" type="text" defaultValue={tag}/>
					<input type="submit" value="Close"/>
				</fieldset>
			</form>
		);
	}
});

var App = React.createClass({
	getInitialState: function() {
		console.log("App.getInitialState()");
		return {
			itemsCache: [],
			items: [],
			settings: {
				headers: ["folder"],
				order: ["horizon", "created"],
				query: ""
			}
		};
	},
	componentDidMount: function() {
		console.log("App.componentDidMount()");
		this.fetchItemsFromServer();
	},
	render: function() {
		console.log("App.render()");
		return (
			<div>
				<TaskListSettings onChanged={this.taskListSettingsChanged}/>
				<TaskList items={this.state.items} headers={this.state.settings.headers} order={this.state.settings.order}
					onTaskChanged={this.onTaskChanged}/>
			</div>
		);
	},
	taskListSettingsChanged: function(settings) {
		console.log("App.taskListSettingsChanged("+settings+")");
		var items = this.chooseItems(this.state.itemsCache, settings);
		this.setState({items: items, settings: settings});
	},
	chooseItems: function(itemsCache, settings) {
		// Filter all the items we have
		var filter = this.createFilterFromQuery(settings.query);
		var items = itemsCache.filter(filter);
		// Sort the chosen items
		return this.sortItems(items, settings);
	},
	sortItems: function(items, settings) {
		var criterion_l = settings.headers.concat(settings.order);
		var comparor = createComparor(criterion_l);
		items.sort(comparor);
		//_.each(items, function(item) { console.log(item.folder, item.horizon); });
		return items;
	},
	fetchItemsFromServer: function() {
		console.log("App.fetchItemsFromServer()");
		var archived = "";
		//if ($("#rdoArchived").prop("checked"))
			//archived = "&archived=true";
		//else if ($("#rdoArchivedOnly").prop("checked"))
			//archived = "&archived=only";
		$.ajax({
			url: "/items?wrapper=items"+archived,
			dataType: 'json',
			success: function(snapshot) {
				var items = this.chooseItems(snapshot.items, this.state.settings);
				this.setState({itemsCache: snapshot.items, items: items});
			}.bind(this),
			error: function(xhr, status, err) {
				console.error(status, err.toString());
			}.bind(this)
		});
	},
	createFilterFromQuery: function(query) {
		var ast = (query) ? JSON.parse(query) : [];
		var filterFromAst = this.filterFromAst
		return function(item) {
			return item.type == "task" && filterFromAst(ast, item);
		}
	},
	filterFromAst: function(ast, item) {
		for (var i in ast) {
			var elem = ast[i];
			var op = elem[0];

			if (op === "AND") {
			}
			else if (op === "OR") {
			}
			// Non-recursive folder query
			else if (op === "folder=") {
				var queryValue = elem[1];
				var itemValue = item.folder.join("/");
				if (!_.isEqual(itemValue, queryValue))
					return false;
			}
			// Folder query (item is in folder or one of it's children)
			else if (op === "folder") {
				var queryValue = elem[1];
				var itemValue = item.folder.join("/");
				//console.log("itemValue: "+itemValue+", "+_.isEqual(itemValue, queryValue)+", "+queryValue.startsWith(itemValue + "/"));
				if (!(_.isEqual(itemValue, queryValue) || itemValue.startsWith(queryValue + "/")))
					return false;
			}
			else {
				var queryName = elem[1];
				if (!item.hasOwnProperty(queryName)) return false;
				var itemValue = item[queryName];

				if (op === "=") {
					var queryValue = elem[2];
					if (!_.isEqual(itemValue, queryValue))
						return false;
				}
				// Contains
				else if (op === "->") {
					var value = elem[2];
					if (!(item.hasOwnProperty(queryName) && item[queryName].indexOf(value) >= 0))
						return false;
				}
			}
		}
		return true;
	},
	onTaskChanged: function(task, callback) {
		console.log("onTaskChanged()");
		console.log(JSON.stringify(task));
	}
});

/*var item0 = { "folder": ['one', 'two'], horizon: 'week', tag: ['mustdo'], title: 'rock around the clock' };

React.render(
	<TaskItem item={item0}/>,
	document.getElementById("test")
);
*/
React.render(
	<App/>,
	document.getElementById("app")
);
</script>
</body>
</html>

